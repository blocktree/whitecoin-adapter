// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: committeememberupdateglobalparametersoperation.go

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *ChainParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChainParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AllowNonMemberWhitelists {
		buf.WriteString(`{"allow_non_member_whitelists":true`)
	} else {
		buf.WriteString(`{"allow_non_member_whitelists":false`)
	}
	if j.CountNonMemberVotes {
		buf.WriteString(`,"count_non_member_votes":true`)
	} else {
		buf.WriteString(`,"count_non_member_votes":false`)
	}
	buf.WriteString(`,"extensions":`)

	{

		obj, err = j.Extensions.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	/* Struct fall back. type=types.FeeSchedule kind=struct */
	buf.WriteString(`,"current_fees":`)
	err = buf.Encode(&j.CurrentFees)
	if err != nil {
		return err
	}
	buf.WriteString(`,"account_fee_scale_bitshifts":`)
	fflib.FormatBits2(buf, uint64(j.AccountFeeScaleBitshifts), 10, false)
	buf.WriteString(`,"block_interval":`)
	fflib.FormatBits2(buf, uint64(j.BlockInterval), 10, false)
	buf.WriteString(`,"maintenance_skip_slots":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceSkipSlots), 10, false)
	buf.WriteString(`,"max_authority_depth":`)
	fflib.FormatBits2(buf, uint64(j.MaxAuthorityDepth), 10, false)
	buf.WriteString(`,"maximum_asset_feed_publishers":`)
	fflib.FormatBits2(buf, uint64(j.MaximumAssetFeedPublishers), 10, false)
	buf.WriteString(`,"maximum_asset_whitelist_authorities":`)
	fflib.FormatBits2(buf, uint64(j.MaximumAssetWhitelistAuthorities), 10, false)
	buf.WriteString(`,"accounts_per_fee_scale":`)
	fflib.FormatBits2(buf, uint64(j.AccountsPerFeeScale), 10, false)
	buf.WriteString(`,"lifetime_referrer_percent_of_fee":`)
	fflib.FormatBits2(buf, uint64(j.LifetimeReferrerPercentOfFee), 10, false)
	buf.WriteString(`,"max_predicate_opcode":`)
	fflib.FormatBits2(buf, uint64(j.MaxPredicateOpcode), 10, false)
	buf.WriteString(`,"maximum_authority_membership":`)
	fflib.FormatBits2(buf, uint64(j.MaximumAuthorityMembership), 10, false)
	buf.WriteString(`,"maximum_committee_count":`)
	fflib.FormatBits2(buf, uint64(j.MaximumCommitteeCount), 10, false)
	buf.WriteString(`,"maximum_witness_count":`)
	fflib.FormatBits2(buf, uint64(j.MaximumWitnessCount), 10, false)
	buf.WriteString(`,"network_percent_of_fee":`)
	fflib.FormatBits2(buf, uint64(j.NetworkPercentOfFee), 10, false)
	buf.WriteString(`,"reserve_percent_of_fee":`)
	fflib.FormatBits2(buf, uint64(j.ReservePercentOfFee), 10, false)
	buf.WriteString(`,"cashback_vesting_period_seconds":`)
	fflib.FormatBits2(buf, uint64(j.CashbackVestingPeriodSeconds), 10, false)
	buf.WriteString(`,"committee_proposal_review_period":`)
	fflib.FormatBits2(buf, uint64(j.CommitteeProposalReviewPeriod), 10, false)
	buf.WriteString(`,"witness_pay_vesting_seconds":`)
	fflib.FormatBits2(buf, uint64(j.WitnessPayVestingSeconds), 10, false)
	buf.WriteString(`,"maximum_proposal_lifetime":`)
	fflib.FormatBits2(buf, uint64(j.MaximumProposalLifetime), 10, false)
	buf.WriteString(`,"maximum_time_until_expiration":`)
	fflib.FormatBits2(buf, uint64(j.MaximumTimeUntilExpiration), 10, false)
	buf.WriteString(`,"maximum_transaction_size":`)
	fflib.FormatBits2(buf, uint64(j.MaximumTransactionSize), 10, false)
	buf.WriteString(`,"maintenance_interval":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceInterval), 10, false)
	buf.WriteString(`,"maximum_block_size":`)
	fflib.FormatBits2(buf, uint64(j.MaximumBlockSize), 10, false)
	buf.WriteString(`,"cashback_vesting_threshold":`)
	fflib.FormatBits2(buf, uint64(j.CashbackVestingThreshold), 10, j.CashbackVestingThreshold < 0)
	buf.WriteString(`,"witness_pay_per_block":`)
	fflib.FormatBits2(buf, uint64(j.WitnessPayPerBlock), 10, j.WitnessPayPerBlock < 0)
	buf.WriteString(`,"worker_budget_per_day":`)
	fflib.FormatBits2(buf, uint64(j.WorkerBudgetPerDay), 10, j.WorkerBudgetPerDay < 0)
	buf.WriteString(`,"fee_liquidation_threshold":`)
	fflib.FormatBits2(buf, uint64(j.FeeLiquidationThreshold), 10, j.FeeLiquidationThreshold < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChainParametersbase = iota
	ffjtChainParametersnosuchkey

	ffjtChainParametersAllowNonMemberWhitelists

	ffjtChainParametersCountNonMemberVotes

	ffjtChainParametersExtensions

	ffjtChainParametersCurrentFees

	ffjtChainParametersAccountFeeScaleBitshifts

	ffjtChainParametersBlockInterval

	ffjtChainParametersMaintenanceSkipSlots

	ffjtChainParametersMaxAuthorityDepth

	ffjtChainParametersMaximumAssetFeedPublishers

	ffjtChainParametersMaximumAssetWhitelistAuthorities

	ffjtChainParametersAccountsPerFeeScale

	ffjtChainParametersLifetimeReferrerPercentOfFee

	ffjtChainParametersMaxPredicateOpcode

	ffjtChainParametersMaximumAuthorityMembership

	ffjtChainParametersMaximumCommitteeCount

	ffjtChainParametersMaximumWitnessCount

	ffjtChainParametersNetworkPercentOfFee

	ffjtChainParametersReservePercentOfFee

	ffjtChainParametersCashbackVestingPeriodSeconds

	ffjtChainParametersCommitteeProposalReviewPeriod

	ffjtChainParametersWitnessPayVestingSeconds

	ffjtChainParametersMaximumProposalLifetime

	ffjtChainParametersMaximumTimeUntilExpiration

	ffjtChainParametersMaximumTransactionSize

	ffjtChainParametersMaintenanceInterval

	ffjtChainParametersMaximumBlockSize

	ffjtChainParametersCashbackVestingThreshold

	ffjtChainParametersWitnessPayPerBlock

	ffjtChainParametersWorkerBudgetPerDay

	ffjtChainParametersFeeLiquidationThreshold
)

var ffjKeyChainParametersAllowNonMemberWhitelists = []byte("allow_non_member_whitelists")

var ffjKeyChainParametersCountNonMemberVotes = []byte("count_non_member_votes")

var ffjKeyChainParametersExtensions = []byte("extensions")

var ffjKeyChainParametersCurrentFees = []byte("current_fees")

var ffjKeyChainParametersAccountFeeScaleBitshifts = []byte("account_fee_scale_bitshifts")

var ffjKeyChainParametersBlockInterval = []byte("block_interval")

var ffjKeyChainParametersMaintenanceSkipSlots = []byte("maintenance_skip_slots")

var ffjKeyChainParametersMaxAuthorityDepth = []byte("max_authority_depth")

var ffjKeyChainParametersMaximumAssetFeedPublishers = []byte("maximum_asset_feed_publishers")

var ffjKeyChainParametersMaximumAssetWhitelistAuthorities = []byte("maximum_asset_whitelist_authorities")

var ffjKeyChainParametersAccountsPerFeeScale = []byte("accounts_per_fee_scale")

var ffjKeyChainParametersLifetimeReferrerPercentOfFee = []byte("lifetime_referrer_percent_of_fee")

var ffjKeyChainParametersMaxPredicateOpcode = []byte("max_predicate_opcode")

var ffjKeyChainParametersMaximumAuthorityMembership = []byte("maximum_authority_membership")

var ffjKeyChainParametersMaximumCommitteeCount = []byte("maximum_committee_count")

var ffjKeyChainParametersMaximumWitnessCount = []byte("maximum_witness_count")

var ffjKeyChainParametersNetworkPercentOfFee = []byte("network_percent_of_fee")

var ffjKeyChainParametersReservePercentOfFee = []byte("reserve_percent_of_fee")

var ffjKeyChainParametersCashbackVestingPeriodSeconds = []byte("cashback_vesting_period_seconds")

var ffjKeyChainParametersCommitteeProposalReviewPeriod = []byte("committee_proposal_review_period")

var ffjKeyChainParametersWitnessPayVestingSeconds = []byte("witness_pay_vesting_seconds")

var ffjKeyChainParametersMaximumProposalLifetime = []byte("maximum_proposal_lifetime")

var ffjKeyChainParametersMaximumTimeUntilExpiration = []byte("maximum_time_until_expiration")

var ffjKeyChainParametersMaximumTransactionSize = []byte("maximum_transaction_size")

var ffjKeyChainParametersMaintenanceInterval = []byte("maintenance_interval")

var ffjKeyChainParametersMaximumBlockSize = []byte("maximum_block_size")

var ffjKeyChainParametersCashbackVestingThreshold = []byte("cashback_vesting_threshold")

var ffjKeyChainParametersWitnessPayPerBlock = []byte("witness_pay_per_block")

var ffjKeyChainParametersWorkerBudgetPerDay = []byte("worker_budget_per_day")

var ffjKeyChainParametersFeeLiquidationThreshold = []byte("fee_liquidation_threshold")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChainParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChainParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChainParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChainParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChainParametersAllowNonMemberWhitelists, kn) {
						currentKey = ffjtChainParametersAllowNonMemberWhitelists
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersAccountFeeScaleBitshifts, kn) {
						currentKey = ffjtChainParametersAccountFeeScaleBitshifts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersAccountsPerFeeScale, kn) {
						currentKey = ffjtChainParametersAccountsPerFeeScale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyChainParametersBlockInterval, kn) {
						currentKey = ffjtChainParametersBlockInterval
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChainParametersCountNonMemberVotes, kn) {
						currentKey = ffjtChainParametersCountNonMemberVotes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersCurrentFees, kn) {
						currentKey = ffjtChainParametersCurrentFees
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersCashbackVestingPeriodSeconds, kn) {
						currentKey = ffjtChainParametersCashbackVestingPeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersCommitteeProposalReviewPeriod, kn) {
						currentKey = ffjtChainParametersCommitteeProposalReviewPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersCashbackVestingThreshold, kn) {
						currentKey = ffjtChainParametersCashbackVestingThreshold
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyChainParametersExtensions, kn) {
						currentKey = ffjtChainParametersExtensions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChainParametersFeeLiquidationThreshold, kn) {
						currentKey = ffjtChainParametersFeeLiquidationThreshold
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChainParametersLifetimeReferrerPercentOfFee, kn) {
						currentKey = ffjtChainParametersLifetimeReferrerPercentOfFee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChainParametersMaintenanceSkipSlots, kn) {
						currentKey = ffjtChainParametersMaintenanceSkipSlots
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaxAuthorityDepth, kn) {
						currentKey = ffjtChainParametersMaxAuthorityDepth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumAssetFeedPublishers, kn) {
						currentKey = ffjtChainParametersMaximumAssetFeedPublishers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumAssetWhitelistAuthorities, kn) {
						currentKey = ffjtChainParametersMaximumAssetWhitelistAuthorities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaxPredicateOpcode, kn) {
						currentKey = ffjtChainParametersMaxPredicateOpcode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumAuthorityMembership, kn) {
						currentKey = ffjtChainParametersMaximumAuthorityMembership
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumCommitteeCount, kn) {
						currentKey = ffjtChainParametersMaximumCommitteeCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumWitnessCount, kn) {
						currentKey = ffjtChainParametersMaximumWitnessCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumProposalLifetime, kn) {
						currentKey = ffjtChainParametersMaximumProposalLifetime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumTimeUntilExpiration, kn) {
						currentKey = ffjtChainParametersMaximumTimeUntilExpiration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumTransactionSize, kn) {
						currentKey = ffjtChainParametersMaximumTransactionSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaintenanceInterval, kn) {
						currentKey = ffjtChainParametersMaintenanceInterval
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersMaximumBlockSize, kn) {
						currentKey = ffjtChainParametersMaximumBlockSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyChainParametersNetworkPercentOfFee, kn) {
						currentKey = ffjtChainParametersNetworkPercentOfFee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChainParametersReservePercentOfFee, kn) {
						currentKey = ffjtChainParametersReservePercentOfFee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyChainParametersWitnessPayVestingSeconds, kn) {
						currentKey = ffjtChainParametersWitnessPayVestingSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersWitnessPayPerBlock, kn) {
						currentKey = ffjtChainParametersWitnessPayPerBlock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersWorkerBudgetPerDay, kn) {
						currentKey = ffjtChainParametersWorkerBudgetPerDay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChainParametersFeeLiquidationThreshold, kn) {
					currentKey = ffjtChainParametersFeeLiquidationThreshold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersWorkerBudgetPerDay, kn) {
					currentKey = ffjtChainParametersWorkerBudgetPerDay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersWitnessPayPerBlock, kn) {
					currentKey = ffjtChainParametersWitnessPayPerBlock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersCashbackVestingThreshold, kn) {
					currentKey = ffjtChainParametersCashbackVestingThreshold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumBlockSize, kn) {
					currentKey = ffjtChainParametersMaximumBlockSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersMaintenanceInterval, kn) {
					currentKey = ffjtChainParametersMaintenanceInterval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumTransactionSize, kn) {
					currentKey = ffjtChainParametersMaximumTransactionSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersMaximumTimeUntilExpiration, kn) {
					currentKey = ffjtChainParametersMaximumTimeUntilExpiration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumProposalLifetime, kn) {
					currentKey = ffjtChainParametersMaximumProposalLifetime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersWitnessPayVestingSeconds, kn) {
					currentKey = ffjtChainParametersWitnessPayVestingSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersCommitteeProposalReviewPeriod, kn) {
					currentKey = ffjtChainParametersCommitteeProposalReviewPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersCashbackVestingPeriodSeconds, kn) {
					currentKey = ffjtChainParametersCashbackVestingPeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersReservePercentOfFee, kn) {
					currentKey = ffjtChainParametersReservePercentOfFee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersNetworkPercentOfFee, kn) {
					currentKey = ffjtChainParametersNetworkPercentOfFee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumWitnessCount, kn) {
					currentKey = ffjtChainParametersMaximumWitnessCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersMaximumCommitteeCount, kn) {
					currentKey = ffjtChainParametersMaximumCommitteeCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumAuthorityMembership, kn) {
					currentKey = ffjtChainParametersMaximumAuthorityMembership
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersMaxPredicateOpcode, kn) {
					currentKey = ffjtChainParametersMaxPredicateOpcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersLifetimeReferrerPercentOfFee, kn) {
					currentKey = ffjtChainParametersLifetimeReferrerPercentOfFee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersAccountsPerFeeScale, kn) {
					currentKey = ffjtChainParametersAccountsPerFeeScale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumAssetWhitelistAuthorities, kn) {
					currentKey = ffjtChainParametersMaximumAssetWhitelistAuthorities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaximumAssetFeedPublishers, kn) {
					currentKey = ffjtChainParametersMaximumAssetFeedPublishers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersMaxAuthorityDepth, kn) {
					currentKey = ffjtChainParametersMaxAuthorityDepth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersMaintenanceSkipSlots, kn) {
					currentKey = ffjtChainParametersMaintenanceSkipSlots
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersBlockInterval, kn) {
					currentKey = ffjtChainParametersBlockInterval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersAccountFeeScaleBitshifts, kn) {
					currentKey = ffjtChainParametersAccountFeeScaleBitshifts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersCurrentFees, kn) {
					currentKey = ffjtChainParametersCurrentFees
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersExtensions, kn) {
					currentKey = ffjtChainParametersExtensions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersCountNonMemberVotes, kn) {
					currentKey = ffjtChainParametersCountNonMemberVotes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersAllowNonMemberWhitelists, kn) {
					currentKey = ffjtChainParametersAllowNonMemberWhitelists
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChainParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChainParametersAllowNonMemberWhitelists:
					goto handle_AllowNonMemberWhitelists

				case ffjtChainParametersCountNonMemberVotes:
					goto handle_CountNonMemberVotes

				case ffjtChainParametersExtensions:
					goto handle_Extensions

				case ffjtChainParametersCurrentFees:
					goto handle_CurrentFees

				case ffjtChainParametersAccountFeeScaleBitshifts:
					goto handle_AccountFeeScaleBitshifts

				case ffjtChainParametersBlockInterval:
					goto handle_BlockInterval

				case ffjtChainParametersMaintenanceSkipSlots:
					goto handle_MaintenanceSkipSlots

				case ffjtChainParametersMaxAuthorityDepth:
					goto handle_MaxAuthorityDepth

				case ffjtChainParametersMaximumAssetFeedPublishers:
					goto handle_MaximumAssetFeedPublishers

				case ffjtChainParametersMaximumAssetWhitelistAuthorities:
					goto handle_MaximumAssetWhitelistAuthorities

				case ffjtChainParametersAccountsPerFeeScale:
					goto handle_AccountsPerFeeScale

				case ffjtChainParametersLifetimeReferrerPercentOfFee:
					goto handle_LifetimeReferrerPercentOfFee

				case ffjtChainParametersMaxPredicateOpcode:
					goto handle_MaxPredicateOpcode

				case ffjtChainParametersMaximumAuthorityMembership:
					goto handle_MaximumAuthorityMembership

				case ffjtChainParametersMaximumCommitteeCount:
					goto handle_MaximumCommitteeCount

				case ffjtChainParametersMaximumWitnessCount:
					goto handle_MaximumWitnessCount

				case ffjtChainParametersNetworkPercentOfFee:
					goto handle_NetworkPercentOfFee

				case ffjtChainParametersReservePercentOfFee:
					goto handle_ReservePercentOfFee

				case ffjtChainParametersCashbackVestingPeriodSeconds:
					goto handle_CashbackVestingPeriodSeconds

				case ffjtChainParametersCommitteeProposalReviewPeriod:
					goto handle_CommitteeProposalReviewPeriod

				case ffjtChainParametersWitnessPayVestingSeconds:
					goto handle_WitnessPayVestingSeconds

				case ffjtChainParametersMaximumProposalLifetime:
					goto handle_MaximumProposalLifetime

				case ffjtChainParametersMaximumTimeUntilExpiration:
					goto handle_MaximumTimeUntilExpiration

				case ffjtChainParametersMaximumTransactionSize:
					goto handle_MaximumTransactionSize

				case ffjtChainParametersMaintenanceInterval:
					goto handle_MaintenanceInterval

				case ffjtChainParametersMaximumBlockSize:
					goto handle_MaximumBlockSize

				case ffjtChainParametersCashbackVestingThreshold:
					goto handle_CashbackVestingThreshold

				case ffjtChainParametersWitnessPayPerBlock:
					goto handle_WitnessPayPerBlock

				case ffjtChainParametersWorkerBudgetPerDay:
					goto handle_WorkerBudgetPerDay

				case ffjtChainParametersFeeLiquidationThreshold:
					goto handle_FeeLiquidationThreshold

				case ffjtChainParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AllowNonMemberWhitelists:

	/* handler: j.AllowNonMemberWhitelists type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowNonMemberWhitelists = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowNonMemberWhitelists = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CountNonMemberVotes:

	/* handler: j.CountNonMemberVotes type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CountNonMemberVotes = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CountNonMemberVotes = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extensions:

	/* handler: j.Extensions type=types.Extensions kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Extensions.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentFees:

	/* handler: j.CurrentFees type=types.FeeSchedule kind=struct quoted=false*/

	{
		/* Falling back. type=types.FeeSchedule kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.CurrentFees)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountFeeScaleBitshifts:

	/* handler: j.AccountFeeScaleBitshifts type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AccountFeeScaleBitshifts.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BlockInterval:

	/* handler: j.BlockInterval type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BlockInterval.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceSkipSlots:

	/* handler: j.MaintenanceSkipSlots type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaintenanceSkipSlots.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxAuthorityDepth:

	/* handler: j.MaxAuthorityDepth type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaxAuthorityDepth.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumAssetFeedPublishers:

	/* handler: j.MaximumAssetFeedPublishers type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumAssetFeedPublishers.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumAssetWhitelistAuthorities:

	/* handler: j.MaximumAssetWhitelistAuthorities type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumAssetWhitelistAuthorities.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountsPerFeeScale:

	/* handler: j.AccountsPerFeeScale type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AccountsPerFeeScale.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LifetimeReferrerPercentOfFee:

	/* handler: j.LifetimeReferrerPercentOfFee type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LifetimeReferrerPercentOfFee.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxPredicateOpcode:

	/* handler: j.MaxPredicateOpcode type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaxPredicateOpcode.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumAuthorityMembership:

	/* handler: j.MaximumAuthorityMembership type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumAuthorityMembership.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumCommitteeCount:

	/* handler: j.MaximumCommitteeCount type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumCommitteeCount.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumWitnessCount:

	/* handler: j.MaximumWitnessCount type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumWitnessCount.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkPercentOfFee:

	/* handler: j.NetworkPercentOfFee type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.NetworkPercentOfFee.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReservePercentOfFee:

	/* handler: j.ReservePercentOfFee type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ReservePercentOfFee.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashbackVestingPeriodSeconds:

	/* handler: j.CashbackVestingPeriodSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashbackVestingPeriodSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitteeProposalReviewPeriod:

	/* handler: j.CommitteeProposalReviewPeriod type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommitteeProposalReviewPeriod.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessPayVestingSeconds:

	/* handler: j.WitnessPayVestingSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessPayVestingSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumProposalLifetime:

	/* handler: j.MaximumProposalLifetime type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumProposalLifetime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumTimeUntilExpiration:

	/* handler: j.MaximumTimeUntilExpiration type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumTimeUntilExpiration.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumTransactionSize:

	/* handler: j.MaximumTransactionSize type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumTransactionSize.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceInterval:

	/* handler: j.MaintenanceInterval type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaintenanceInterval.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumBlockSize:

	/* handler: j.MaximumBlockSize type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumBlockSize.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashbackVestingThreshold:

	/* handler: j.CashbackVestingThreshold type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashbackVestingThreshold.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessPayPerBlock:

	/* handler: j.WitnessPayPerBlock type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessPayPerBlock.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkerBudgetPerDay:

	/* handler: j.WorkerBudgetPerDay type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WorkerBudgetPerDay.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FeeLiquidationThreshold:

	/* handler: j.FeeLiquidationThreshold type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.FeeLiquidationThreshold.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CommitteeMemberUpdateGlobalParametersOperation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CommitteeMemberUpdateGlobalParametersOperation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "new_parameters":`)

	{

		err = j.NewParameters.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if j.Fee != nil {
		if true {
			/* Struct fall back. type=types.AssetAmount kind=struct */
			buf.WriteString(`"fee":`)
			err = buf.Encode(j.Fee)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCommitteeMemberUpdateGlobalParametersOperationbase = iota
	ffjtCommitteeMemberUpdateGlobalParametersOperationnosuchkey

	ffjtCommitteeMemberUpdateGlobalParametersOperationNewParameters

	ffjtCommitteeMemberUpdateGlobalParametersOperationFee
)

var ffjKeyCommitteeMemberUpdateGlobalParametersOperationNewParameters = []byte("new_parameters")

var ffjKeyCommitteeMemberUpdateGlobalParametersOperationFee = []byte("fee")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CommitteeMemberUpdateGlobalParametersOperation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CommitteeMemberUpdateGlobalParametersOperation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCommitteeMemberUpdateGlobalParametersOperationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyCommitteeMemberUpdateGlobalParametersOperationFee, kn) {
						currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationFee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyCommitteeMemberUpdateGlobalParametersOperationNewParameters, kn) {
						currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationNewParameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyCommitteeMemberUpdateGlobalParametersOperationFee, kn) {
					currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationFee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCommitteeMemberUpdateGlobalParametersOperationNewParameters, kn) {
					currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationNewParameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCommitteeMemberUpdateGlobalParametersOperationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCommitteeMemberUpdateGlobalParametersOperationNewParameters:
					goto handle_NewParameters

				case ffjtCommitteeMemberUpdateGlobalParametersOperationFee:
					goto handle_Fee

				case ffjtCommitteeMemberUpdateGlobalParametersOperationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_NewParameters:

	/* handler: j.NewParameters type=operations.ChainParameters kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.NewParameters.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fee:

	/* handler: j.Fee type=types.AssetAmount kind=struct quoted=false*/

	{
		/* Falling back. type=types.AssetAmount kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Fee)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
